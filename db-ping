#!/usr/bin/python3
"""
MariaDB/MySQL compatible database connection and capability checker

This tool helps to quickly identify database connectivity issues such as:
- DNS propagation delay, hostname not matching active database server
- TCP/IP routing issues, server not reachable
- TLS certificate issues
- Authentication errors
- Server load issues: too many connections, too many queries or too much load
- Server health issues: disk write operations stalled or other I/O delay

Example invocation and output:
    $ db-ping --host database-1.example.com --user dbuser --password abc123 appdb
    Connecting dbuser@database-1.example.com:3306...
    Executed 1 DELETE in 0.01 ms, 1 INSERT in 0.12 ms, 1 UPDATE in 0.1 ms, 1 SELECT in 0.01 ms
    Executed 1 DELETE in 0.01 ms, 1 INSERT in 0.12 ms, 1 UPDATE in 0.1 ms, 1 SELECT in 0.01 ms
    Executed 1 DELETE in 0.01 ms, 1 INSERT in 0.12 ms, 1 UPDATE in 0.1 ms, 1 SELECT in 0.01 ms
    ^C
    --- database-1.example.com db-ping statistics ---
    3 DELETE in 0.2 ms (min/avg/max 0.01/0.01/0.01)
    3 INSERT in 0.36 ms (min/avg/max 0.12/0.12/0.12)
    3 UPDATE in 0.2 ms (min/avg/max 0.01/0.01/0.01)
    1 SELECT in 0.03 ms (min/avg/max 0.03/0.03/0.03)
    SQL execution time: 0.79 ms
    Wall clock duration: 3.02 seconds
    Connection errors/connects: 0
    Availability: 100.00%

Database server, name and user credentials can be given as command-line
parameters or they are read from environment variables DB_* or from .my.cnf
config files.

Database hostname and user password don't have any defaults, they must be given.
Default username and database is 'db-ping'. The database will be used to create
a small table 'db-ping' which will have random values written and read in order
to verify that the database server accepts both reads and writes, and for example
the filesystem is not stuck. If no database name is given, db-ping will attempt
to create the table inside the 'tmp' or 'test' database, if such exists.

It is recommended to use the application credentials when running db-ping to
verify that everything would work just as the application would see it. The
test table is safely created also inside a production database, as it will always
be a separate table that nobody else uses, called 'db-ping'.
"""

import argparse
import configparser
import copy
import mariadb
import sys
import os
import re
import socket
import time
import threading

import worker_status
import worker_reader
import worker_writer
import worker_ping

from pprint import pprint
import inspect

# Configuration parameters, some with default values
config = {
    'verbose': False,
    'host': 'localhost',
    'port': 3306,
    'user': 'db-ping',
    'password': '',
    'database': '',
}

# As config names are not identical to their expected environment variable
# names, create a map of them
configEnvMap = {
    'host': 'DB_HOST',
    'port': 'DB_PORT',
    'user': 'DB_USER',
    'password': 'DB_PASSWORD',
    'database': 'DB_NAME',
}

configFromEnvironmentVariables = []
configFromConfigFiles = []

# Read a my.cnf if exists
# Note that file must have some kind of [section], otherwise ConfigParser will
# fail with "configparser.MissingSectionHeaderError: File contains no section headers."
# See https://bugs.python.org/issue22253 and https://github.com/python/cpython/pull/2735
mycnf = configparser.ConfigParser(strict=False)
mycnf.read(['.my.cnf', os.path.expanduser('~/.my.cnf')])

# An alternative source would be to run 'mariadb --print-defaults' and read the
# values it returned. This would evaluate the [client], [mariadb-client] etc
# sections in correct order.

# ArgumentParser shows help texts automatically based on Python docstring
# (the comment at the top of the file)
parser = argparse.ArgumentParser(
    formatter_class=argparse.RawDescriptionHelpFormatter,
    description=__doc__.strip().split('\n', maxsplit=1)[0],
    epilog=__doc__.strip().split('\n', maxsplit=1)[1],
)
parser.add_argument('--host', help='Database server hostname or IP address')
parser.add_argument('--port', type=int, help='Database server port')
parser.add_argument('--user', help='Database username')
parser.add_argument('--password', help='Database user password')
parser.add_argument('--database', help='Database name')
parser.add_argument('--verbose', help='Increase verbosity', action='store_true')
args = parser.parse_args()

# Override default config values with:
# 1. Values from command-line arguments
# 2. Values from environment variables
# 3. Values from my.cnf
for key in config:
    if key in args and getattr(args, key) != None:
        config[key] = getattr(args, key)
    elif key in configEnvMap.keys() and configEnvMap[key] in os.environ and os.environ[configEnvMap[key]]:
        config[key] = os.environ[configEnvMap[key]]
        configFromEnvironmentVariables.append(configEnvMap[key])
    elif 'client' in mycnf.sections() and mycnf.has_option('client', key):
        config[key] = mycnf.get('client', key)
        configFromConfigFiles.append(key)

if config['verbose'] and len(configFromEnvironmentVariables) > 0:
    print('Using envs:', ', '.join(configFromEnvironmentVariables))

if config['verbose'] and len(configFromConfigFiles) > 0:
    print('Using .my.cnf:', ', '.join(configFromConfigFiles))

print(
    'Connecting {}@{}:{}...'.format(
        config['user'],
        config['host'],
        config['port'],
    )
)



def new_connection(config):
    #pprint(dir(mariadb))
    #pprint(inspect.getmembers(mariadb))
    conn = mariadb.connect(
        user=config['user'],
        password=config['password'],
        host=config['host'],
        port=config['port'],
        database=config['database'],
        connect_timeout=10,
        read_timeout=10,
        write_timeout=10,
        ssl=True,  # Force TLS protection
    )
    # https://mariadb-corporation.github.io/mariadb-connector-python/connection.html#auto_reconnect
    conn.auto_reconnect = True;
    return conn

# Measure total wall clock time for execution
start = time.time()

try:
    conn = new_connection(config)
except mariadb.Error as e:
    print(f'Connection failed: {e}')
    connection_time = round(time.time() - connect_start, 1)
    if round(connection_time) == 10:
        print('ERROR: Timeout after 10 seconds')
    else:
        print(f'Connection closed after {connection_time} seconds')
    sys.exit(1)

# Check if host stars like an IPv4 or IPv6 address
if re.search('(^[0-9]{1,3}\.)|(^[0-9a-fA-F]{1,4}:)', config['host']):
    # Show what name IP resolves to
    addr_info = socket.gethostbyaddr(config['host'])[0]
else:
    # Show what IP name resolves to
    # Define type=6 to only get each IP only once in result set
    addrinfo = socket.getaddrinfo(config['host'], config['port'], 0, 6)
    ip_list = list()
    for addr in addrinfo:
        ip_list.append(addr[4][0])
    addr_info = ', '.join(ip_list)

# @TODO: Check DNS server TTL time and repeat the lookup on that interval
# @TODO: Check DNS server if CNAME and follow chain until A or AAAA records

print(f'Successfully connected to {conn.server_name} ({addr_info})')

#pprint(dir(conn))
#pprint(inspect.getmembers(conn))

server_debug = [
    'server_port',
    'user',
    'database',
    'tls_cipher',
    'tls_version',
    'server_info',
    'server_version_info',
    'character_set',
    'collation',
    'dsn',
    'warnings',
    'connection_id',
#    'auto_reconnect',
]

if config['verbose']:
    for i in server_debug:
        print(' ', i + ':', getattr(conn, i))

# Run multiple parallel threads to prevent connections or printing of results
# stalling because of any single timeout or network I/O or remote disk I/O issue
threads = list()

# Flag to tell other threads we'd like to stop
control = {
    'config': config,
    'run': True
}

# Shared counters
# Prevent race conditions by ensuring each thread only writes to a branch of
# the dict that nobody else writes to. Summarize all stats in main thread code.
counters = {
    'ping': {
        'id': 0,  # connection id
        'connects': 0,
        'seq': 0,  # sequence number, always increments by one
        'time': 0.0,  # time logged for latest
    },
    'read': {
        'id': 0,
        'connects': 0,
        'seq': 0,
        'time': 0.0,
    },
    'write': {
        'id': 0,
        'connects': 0,
        'seq': 0,
        'time': 0.0,
    },
    'seq': 1,  # Start top-level print counter at 1
}

# Copy of previous values
old_counters = copy.deepcopy(counters)

def print_status(now, previous):
    # Don't print anything on the very first run when counters are empty
    if now['ping']['seq'] == 0:
        return

    if now['ping']['seq'] == previous['ping']['seq']:
        print('Ping taking longer than 1 second...')
        return

    if now['ping']['id'] != previous['ping']['id'] or \
       now['read']['id'] != previous['read']['id']:
        print('Database client reconnected')

    print(
        '#{} {}s (connects: {}/4)'.format(
            counters['seq'],
            round(counters['ping']['time'], 2),
            1 + now['ping']['connects'] + now['read']['connects'] + now['write']['connects'],
        )
    )

    # Increment counter on every printed line
    now['seq'] += 1


def print_summary(now, previous):
    print(f'--- database server {config["host"]} summary ---')
    print('Wall clock duration:', round(time.time() - start), 'seconds')
    print('# Total:', counters['seq'])
    print('# Pings:', counters['ping']['seq'], '(SLA:', 100*(counters['ping']['seq']/counters['seq']), '%)')
    print('# Reads:', counters['read']['seq'], '(SLA:', 100*(counters['read']['seq']/counters['seq']), '%)')
    print('# Writes:', counters['write']['seq'], '(SLA:', 100*(counters['write']['seq']/counters['seq']), '%)')


try:
    # Add thread for general database information and printer
    threads.append(
        threading.Thread(
            target=worker_status.run,
            kwargs={'conn': conn, 'control': control, 'counters': counters}
        )
    )

    # Add thread for database client ping
    threads.append(
        threading.Thread(
            target=worker_ping.run,
            kwargs={'conn': new_connection(config), 'control': control, 'counters': counters}
        )
    )

    # Add thread for database reader
    threads.append(
        threading.Thread(
            target=worker_reader.run,
            kwargs={'conn': new_connection(config), 'control': control, 'counters': counters}
        )
    )

    # Add thread for database writer
    threads.append(
        threading.Thread(
            target=worker_writer.run,
            kwargs={'conn': new_connection(config), 'control': control, 'counters': counters}
        )
    )


    # Start all threads
    for i in range(0, len(threads)):
        threads[i].start()

    while control['run']:
        print_status(counters, old_counters)
        old_counters = copy.deepcopy(counters)
        time.sleep(1.1)  # Must be a bit slower than threads to allow them time to complete
        # However, this leads to main thread and child processes run different amount of #

    # Wait for all threads to complete
    # @TODO: Not really necessary for when Ctrl+C is the exit method
    for i in range(0, len(threads)):
        threads[i].join()
    print('This will never print :)')

except KeyboardInterrupt:
    control['run'] = False
    print('Aborting on CTRL+C...')

finally:
    print('Threads stopped')
    print_summary(counters, old_counters)

# Free resources
conn.close()
